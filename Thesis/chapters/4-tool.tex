\chapter{Tool}
\label{chp:tool}

Evaluation of multiple architectures by hand is a tedious and time-consuming task, so finding a way to automate this process is essential.
A tool was developed to accelerate the evaluation of a vehicle network architecture based on their attack path feasibility
by automatically generating the most feasible attack paths for the different complex architectures, as well as evalaute them based on the criteria.

The following sections will describe the tool's implementation.

\section{Configuration Files Structure}
\label{sec:config}

First, the architecture, \acrshort{ecu}s and buses need to be defined in a configuration file.
The configuration files for the simulation are stored in JSON format, 
which is a lightweight data interchange format that is easy to read and write, and easy for machines to parse and generate.\\

There are three main configuration files used in the simulation: buses.json, ecus.json, and graph.json.
Each file has a specific structure and contains different attributes.

\subsection{buses.json}
\label{sec:buses}

The tool takes as input three sets of configuration files, each of them represented in the JSON format: 
the system architecture, the \acrshort{ecu}s in the system, and the buses connecting the \acrshort{ecu}s. 

This file defines the different communication buses that are used in the simulation. 
It contains an array of objects, where each object represents a bus and has the following attributes:

\begin{itemize}
\item \textbf{type}: The type of the bus: \textit{\acrshort{can}, \acrshort{canfd}, \acrshort{flexray}, Ethernet, MOST, LIN}.
\item \textbf{feasibility rating}: A value between 0 and 1 indicating the bus' attack feasibility (\textit{see \ref{table:bus_rating}}).
\end{itemize}

\subsection{ecus.json}
\label{sec:ecus}

This file defines the electronic control units (\acrshort{ecu}s) that are used in the simulation. 

It contains an array of objects, where each object represents an \acrshort{ecu} and has the following attributes:

\begin{itemize}
\item \textbf{name}: The name of the \acrshort{ecu}.
\item \textbf{type}: The type of the \acrshort{ecu} (e.g., entry, target, interface).
\item \textbf{feasibility rating}: A value between 0 and 1 indicating the \acrshort{ecu}'s attack feasibility (\textit{see \ref{table:ecu_rating}}).
\end{itemize}

\subsection{graph.json}
\label{sec:graph}

This file defines the topology of the system being simulated, i.e. the architecture. 
It contains an array of objects, where each object represents a communication link which contains the \acrshort{ecu}s and interfaces and has the following attributes:

\begin{itemize}
\item \textbf{name}: The name of the link.
\item \textbf{type}: The type of the link (\textit{\acrshort{can}, \acrshort{canfd}, \acrshort{flexray}, Ethernet, \acrshort{most}, \acrshort{lin} Bluetooth, WiFi, Ethernet, \acrshort{gnss}}).
\item \textbf{\acrshort{ecu}s}: An array of the names of the \acrshort{ecu}s that are connected by this link.
\end{itemize}

Note that external interfaces (e.g., Bluetooth, WiFi, \acrshort{gnss}) are also considered as \acrshort{ecu}s as well as buses in the simulation.
Treating them as such simplifies the implementation of the tool using the following libraries.
The feasibility of the interface can be set in either the buses.json or ecus.json file, however it is recommended to set it in the buses.json file.
Whichever file is used, note that the feasibility must be set to 0 in the other file, to avoid double counting.


\section{Tool Implementation}
\label{sec:implementation}

The tool is implemented in Python 3.10 and newer.
Python was chosen as the implementation language because it is a script-based language, allowing for quick prototyping and development,
and is popular in the security domain.
Additionally, the language offers a vast variety of libraries that can be used to implement the tool.
The most important and useful library in the tool is \textit{networkx} for graph manipulation and generation.\\

\texttt{main()} calls the following functions, which are integral to the tool's functionality:\\

\texttt{parse\_files(architecture, ecu, bus)}: it takes in three parameters: \texttt{architecture, ecu, bus}.
They are the above described configuration files and loads the contents of these files. 
Specifically, the function loads the contents of the architecture file, \acrshort{ecu} file and bus file, 
and extracts the architecture name, architecture, \acrshort{ecu}s configuration, and buses configuration, respectively. 
The function returns these four objects as a tuple.\\

\texttt{generate\_graph(architecture, ecus\_config, buses\_config)}:\\
This function takes three arguments as input: 
\texttt{architecture}, \texttt{ecus\_config}, and \texttt{buses\_config}. 
The function processes this input to create a directed graph \texttt{(nx.DiGraph())} 
that represents the system's architecture and computes the feasibility between various nodes (\acrshort{ecu}s). 
It returns the generated graph, a list of entry points, and a list of target \acrshort{ecu}s.

\begin{algorithm}[h]
    \caption{Generate Graph}
    \label{alg:generate_graph}
    \begin{algorithmic}[1]
    \Procedure{generate\_graph}{$architecture, ecus\_config, buses\_config$}
        \State $entry\_points \gets$ \Call{EmptyList}{}
        \State $target\_ecus \gets$ \Call{EmptyList}{}
        \State $G \gets$ \Call{nx.DiGraph}{}
        \ForAll{$bus \in architecture$}
            \State $bus\_type, bus\_feasibility, bus\_ecus \gets$ \Call{ExtractInfo}{$bus$}
            \ForAll{$ecu \in bus\_ecus$}
                \State $ecu\_type, ecu\_feasibility \gets$ \Call{ExtractInfo}{$ecu, ecus\_config$}
                \If{$ecu\_type$ is $entry$ or $both$}
                    \State \Call{Append}{$entry\_points, ecu$}
                \EndIf
                \If{$ecu\_type$ is $target$ or $both$}
                    \State \Call{Append}{$target\_ecus, ecu$}
                \EndIf
                \ForAll{$target\_ecu \in bus\_ecus$}
                    \If{$target\_ecu$ is interface}
                        \State \Call{G.addEdge}{$ecu, target\_ecu, weight=bus\_feasibility$}
                    \Else
                        \State $target\_ecu\_feasibility \gets$ \Call{ExtractInfo}{$target\_ecu, ecus\_config$}
                        \State \Call{G.addEdge}{$ecu, target\_ecu, weight=bus\_feasibility + target\_ecu\_feasibility$}
                    \EndIf
                \EndFor
            \EndFor
        \EndFor
        \State $entry\_points \gets$ \Call{MakeUnique}{$entry\_points$}
        \State $target\_ecus \gets$ \Call{Set}{$target\_ecus$}
        \State \Return $G, entry\_points, target\_ecus$
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

\textit{Note: This is why it was easier to treat external interfaces as \acrshort{ecu}s as well as buses.
Since we are looking for the shortest path for an interface type, not the \acrshort{ecu} using it, treating all interfaces
as a bus and \acrshort{ecu} conntected to the internal \acrshort{ecu}s using such interface facilitates the shortest path generation.}\\
The function returns the generated graph, along with the entry \acrshort{ecu}s and target \acrshort{ecu}s lists.\\


\texttt{find\_attack\_path}: 
This function is designed to find the feasibility and the shortest path from each entry \acrshort{ecu} 
to each target \acrshort{ecu} in a given directed graph \texttt{(nx.DiGraph)}.

\begin{algorithm}[h]
    \caption{Find Attack Path}
    \label{alg:findattackpath}
    \begin{algorithmic}[1]
    \Procedure{FindAttackPath}{$G, entry\_points, target\_ecus\_names$}
        \State $table \gets$ \Call{EmptyDict}{}
        \State $table["feasibility"] \gets$ \Call{EmptyDict}{}
        \State $table["shortest\_path"] \gets$ \Call{EmptyDict}{}
        \State $table["hops"] \gets$ \Call{EmptyDict}{}
        \ForAll{$entry \in entry\_points$}
            \State $table["feasibility"][entry] \gets$ \Call{EmptyDict}{}
            \State $table["shortest\_path"][entry] \gets$ \Call{EmptyDict}{}
            \State $table["hops"][entry] \gets$ \Call{EmptyDict}{}
            \ForAll{$target \in target\_ecus\_names$}
                \State $table["feasibility"][entry][target] \gets$ \Call{BellmanFord}{$G, entry, target$}
                \State $table["shortest\_path"][entry][target] \gets$ \Call{nx.shortest\_path}{$G, entry, target$}
                \If{$\text{length}(table["shortest\_path"][entry][target]) \geq 2$}
                    \State $table["hops"][entry][target] \gets \text{length}(table["shortest\_path"][entry][target]) - 2$
                \Else
                    \State $table["hops"][entry][target] \gets 0$
                \EndIf
            \EndFor
        \EndFor
        \State \Return $table$
    \EndProcedure
    \end{algorithmic}
\end{algorithm}
    
The resulting table can be used to analyze the most feasible attack paths between 
various entry points and target \acrshort{ecu}s in the system's architecture.\\

Finally, \texttt{apply\_criteria} applies the \nameref{chp:criteria} to the table.
Each architecture receives a feasibility score and the result can be interpreted as a benchmark for the architecture's security.\\
Since the evaluation of the feasibility of the architecture is represented by a single number, 
it is easy to rank and compare the results of different architectures, which the function is also designed to do.\\

It is easy to extend the tool to support other criteria.\\

Various \textit{I/O functions} are responsible for printing the results, saving them to an external file, or quickly saving the graph as an image file
and other \textit{helper functions} are used to simplify the code.

Below is the implementation of the Bellman-Ford algorithm used in \texttt{\nameref{alg:findattackpath}}.

The Bellman-Ford algorithm is a graph search algorithm that computes 
the shortest paths from a single source vertex to all other vertices in a weighted graph.
It is very similar to the Dijkstra algorithm, but it can work with negative edge weights.\\T
Both algorithms are possible solutions to the our proble, but we chose the Bellman-Ford algorithm because it was mentioned in \cite{threat_surf}.

\begin{algorithm}[h]
    \caption{Bellman-Ford Algorithm}
    \begin{algorithmic}[1]
    \Procedure{BellmanFord}{$Graph, source$}
        \ForAll{$vertex \in Graph.vertices$}
            \State $distance[vertex] \gets \infty$
            \State $predecessor[vertex] \gets \text{null}$
        \EndFor
        \State $distance[source] \gets 0$
        \For{$i \gets 1$ to $|Graph.vertices| - 1$}
            \ForAll{$edge \in Graph.edges$}
                \If{$distance[edge.source] + edge.weight < distance[edge.target]$}
                    \State $distance[edge.target] \gets distance[edge.source] + edge.weight$
                    \State $predecessor[edge.target] \gets edge.source$
                \EndIf
            \EndFor
        \EndFor
        \ForAll{$edge \in Graph.edges$}
            \If{$distance[edge.source] + edge.weight < distance[edge.target]$}
                \State \Return "Graph contains a negative-weight cycle"
            \EndIf
        \EndFor
        \State \Return $distance, predecessor$
    \EndProcedure
    \end{algorithmic}
\end{algorithm}